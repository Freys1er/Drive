<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Network Graph</title>
    <style>
        :root {
            --bg-color: #000000;
            --text-color: #ffffff;
            --line-color: #444444;
            --ui-bg: rgba(0, 0, 0, 0.8);
            --border-color: #333333;
        }

        body {
            margin: 0;
            padding: 0;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            overflow: hidden;
            height: 100vh;
            display: flex;
            flex-direction: column;
            user-select: none;
            -webkit-user-select: none;
        }

        /* --- UI Overlay --- */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            z-index: 10;
        }

        header {
            padding: 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            pointer-events: auto;
            backdrop-filter: blur(2px);
        }

        h1 {
            margin: 0;
            font-size: 1rem;
            font-weight: 400;
            letter-spacing: 1px;
            color: #888;
        }

        .btn {
            background: #111;
            border: 1px solid var(--border-color);
            color: #eee;
            padding: 8px 12px;
            cursor: pointer;
            border-radius: 4px;
            font-size: 0.85rem;
            transition: all 0.2s;
        }

        .btn:hover {
            background: #333;
            border-color: #666;
        }

        .btn-primary {
            background: #fff;
            color: #000;
            font-weight: bold;
            border: none;
        }

        /* --- Controls Bar --- */
        #controls-bar {
            padding: 15px;
            display: flex;
            gap: 10px;
            pointer-events: auto;
            justify-content: center;
            background: linear-gradient(0deg, rgba(0, 0, 0, 1) 0%, rgba(0, 0, 0, 0) 100%);
        }

        input[type="text"] {
            padding: 8px;
            border-radius: 4px;
            border: 1px solid var(--border-color);
            background: #111;
            color: white;
            width: 120px;
        }

        input:focus {
            outline: none;
            border-color: #888;
        }

        /* --- Canvas --- */
        #network-container {
            flex: 1;
            position: relative;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: var(--bg-color);
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
            touch-action: none;
            /* Critical for custom pinch/zoom */
        }

        /* --- Hint Text --- */
        .hint {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #444;
            font-size: 0.8rem;
            pointer-events: none;
            text-align: center;
        }

        /* --- Loading / Auth Screen --- */
        #auth-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--bg-color);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
        }
    </style>
</head>

<body>

    <!-- Auth / Loading Overlay -->
    <div id="auth-screen">
        <h1 style="margin-bottom: 20px; font-size: 1.5rem; color: #fff;">Network Graph</h1>
        <p id="status-text" style="color:#666;">Initializing...</p>
        <button id="auth-btn" class="btn btn-primary" style="display:none; margin-top: 20px;">Connect Google
            Contacts</button>
    </div>

    <!-- Main Application -->
    <div id="ui-layer" style="display:none;">
        <header>
            <h1>CONTACTS</h1>
            <button id="signout-btn" class="btn">Logout</button>
        </header>

        <div class="hint" id="hint-msg">Double-tap node to open contact</div>

        <div id="controls-bar">
            <input type="text" id="find-input" placeholder="Search...">
            <button id="find-button" class="btn">Find</button>
            <button id="reset-cam-button" class="btn">Reset</button>
        </div>
    </div>

    <div id="network-container">
        <canvas id="network-canvas"></canvas>
    </div>

    <!-- Google API Script -->
    <script src="https://apis.google.com/js/api.js"></script>
    <script src="https://accounts.google.com/gsi/client"></script>

    <script>
        // ================= CONFIGURATION =================
        // TODO: Replace with your own Client ID
        const CLIENT_ID = '490934668566-p1068rrenfhl8n5p5mgqaejt748v1880.apps.googleusercontent.com';
        const API_KEY = '';
        const DISCOVERY_DOC = 'https://www.googleapis.com/discovery/v1/apis/people/v1/rest';
        const SCOPES = 'https://www.googleapis.com/auth/contacts.readonly';

        let tokenClient;
        let gapiInited = false;
        let gisInited = false;
        let allContacts = [];

        // ================= AUTHENTICATION =================

        function gapiLoaded() {
            gapi.load('client', async () => {
                await gapi.client.init({ discoveryDocs: [DISCOVERY_DOC] });
                gapiInited = true;
                checkAuth();
            });
        }

        function gisLoaded() {
            // Initialize the Token Client with the callback defined immediately
            tokenClient = google.accounts.oauth2.initTokenClient({
                client_id: CLIENT_ID,
                scope: SCOPES,
                callback: handleAuthResponse, // Defined below
            });
            gisInited = true;
            checkAuth();
        }

        // Callback function for the Auth response
        async function handleAuthResponse(resp) {
            if (resp.error) {
                console.error("Auth Error:", resp);
                if (resp.error === 'popup_closed_by_user') {
                    document.getElementById('status-text').textContent = "Login cancelled.";
                }
                return;
            }
            // Save token and load data
            localStorage.setItem('google_access_token', resp.access_token);
            loadGoogleContacts();
        }

        function checkAuth() {
            if (gapiInited && gisInited) {
                const token = localStorage.getItem('google_access_token');
                if (token) {
                    gapi.client.setToken({ access_token: token });
                    loadGoogleContacts();
                } else {
                    document.getElementById('status-text').textContent = "Sign in required to view graph.";
                    document.getElementById('auth-btn').style.display = 'block';
                }
            }
        }

        document.getElementById('auth-btn').addEventListener('click', () => {
            // Trigger the popup
            if (tokenClient) {
                tokenClient.requestAccessToken({ prompt: 'consent' });
            }
        });

        document.getElementById('signout-btn').addEventListener('click', () => {
            const token = gapi.client.getToken();
            if (token !== null) {
                google.accounts.oauth2.revoke(token.access_token);
                gapi.client.setToken('');
                localStorage.removeItem('google_access_token');
                location.reload();
            }
        });

        // ================= DATA FETCHING =================

        async function loadGoogleContacts() {
            document.getElementById('auth-btn').style.display = 'none';
            document.getElementById('status-text').textContent = "Loading contacts...";

            try {
                // Fetch connections
                const response = await gapi.client.people.people.connections.list({
                    'resourceName': 'people/me',
                    'pageSize': 1000,
                    'personFields': 'names,photos,emailAddresses,organizations,relations'
                });

                const connections = response.result.connections || [];

                if (connections.length === 0) {
                    document.getElementById('status-text').textContent = "No contacts found.";
                    return;
                }

                processContacts(connections);

                document.getElementById('auth-screen').style.display = 'none';
                document.getElementById('ui-layer').style.display = 'flex';

                // Hint fade out
                setTimeout(() => {
                    const hint = document.getElementById('hint-msg');
                    if (hint) hint.style.opacity = 0;
                }, 5000);

            } catch (err) {
                console.error("API Error:", err);
                document.getElementById('status-text').textContent = "Error loading data.";

                // If token is invalid, force logout
                if (err.status === 401 || err.status === 403) {
                    localStorage.removeItem('google_access_token');
                    document.getElementById('status-text').textContent = "Session expired. Please login again.";
                    document.getElementById('auth-btn').style.display = 'block';
                }
            }
        }

        function processContacts(googleData) {
            allContacts = googleData.map(person => {
                const name = person.names ? person.names[0].displayName : 'Unknown';
                const photo = person.photos ? person.photos[0].url : null;
                const relations = person.relations ? person.relations.map(r => ({
                    targetName: r.person,
                    type: r.type
                })) : [];

                let rawId = person.resourceName ? person.resourceName.replace('people/', '') : '';

                return { id: person.resourceName, rawId: rawId, name, photo, relations };
            });

            initializeNetworkGraph(allContacts);
        }

        // ================= GRAPH LOGIC =================

        function initializeNetworkGraph(contacts) {
            const canvas = document.getElementById('network-canvas');
            const ctx = canvas.getContext('2d');
            const container = document.getElementById('network-container');

            // 1. Setup Nodes
            const nameToIdMap = new Map();
            const nodes = contacts.map(c => {
                if (c.name) nameToIdMap.set(c.name.toLowerCase().trim(), c.id);
                return {
                    id: c.id,
                    data: c,
                    x: (Math.random() - 0.5) * 600,
                    y: (Math.random() - 0.5) * 600,
                    vx: 0, vy: 0,
                    img: null,
                    isLoaded: false
                };
            });

            // Preload Images
            nodes.forEach(node => {
                if (node.data.photo) {
                    const img = new Image();
                    img.crossOrigin = "Anonymous";
                    img.src = node.data.photo;
                    img.onload = () => { node.img = img; node.isLoaded = true; };
                }
            });

            // 2. Setup Edges
            const edges = [];
            const edgeExists = (a, b) => edges.some(e => (e.source === a && e.target === b) || (e.source === b && e.target === a));

            contacts.forEach(source => {
                if (!source.relations) return;
                source.relations.forEach(rel => {
                    const targetId = nameToIdMap.get(rel.targetName.toLowerCase().trim());
                    if (targetId && targetId !== source.id && !edgeExists(source.id, targetId)) {
                        edges.push({ source: source.id, target: targetId });
                    }
                });
            });

            // --- View State ---
            let scale = 0.8;
            let viewOffset = { x: 0, y: 0 };
            const NODE_RADIUS = 10;

            // --- Touch/Mouse Logic ---
            let isDragging = false;
            let lastPos = { x: 0, y: 0 };
            let lastTap = 0;
            let initialPinchDist = null;
            let initialScale = null;

            function getPointerPos(e) {
                if (e.touches) {
                    return { x: e.touches[0].clientX, y: e.touches[0].clientY };
                }
                return { x: e.clientX, y: e.clientY };
            }

            function getWorldPos(clientX, clientY) {
                const rect = canvas.getBoundingClientRect();
                return {
                    x: (clientX - rect.left - rect.width / 2 - viewOffset.x) / scale,
                    y: (clientY - rect.top - rect.height / 2 - viewOffset.y) / scale
                };
            }

            function getNodeAt(x, y) {
                return nodes.find(n => {
                    const dx = n.x - x;
                    const dy = n.y - y;
                    return (dx * dx + dy * dy) < (NODE_RADIUS * NODE_RADIUS);
                });
            }

            // Input Event Handlers
            function onDown(e) {
                // Pinch Start
                if (e.touches && e.touches.length === 2) {
                    const dx = e.touches[0].clientX - e.touches[1].clientX;
                    const dy = e.touches[0].clientY - e.touches[1].clientY;
                    initialPinchDist = Math.sqrt(dx * dx + dy * dy);
                    initialScale = scale;
                    return;
                }

                const pos = getPointerPos(e);
                lastPos = pos;
                isDragging = true;

                // Double Tap Logic
                const currentTime = new Date().getTime();
                const tapLength = currentTime - lastTap;

                if (tapLength < 300 && tapLength > 0) {
                    const worldPos = getWorldPos(pos.x, pos.y);
                    const clickedNode = getNodeAt(worldPos.x, worldPos.y);
                    if (clickedNode) {
                        openGoogleContact(clickedNode.data);
                    }
                }
                lastTap = currentTime;
            }

            function onMove(e) {
                // Pinch Zoom
                if (e.touches && e.touches.length === 2 && initialPinchDist) {
                    const dx = e.touches[0].clientX - e.touches[1].clientX;
                    const dy = e.touches[0].clientY - e.touches[1].clientY;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    const ratio = dist / initialPinchDist;
                    scale = Math.min(Math.max(0.1, initialScale * ratio), 5);
                    return;
                }

                // Panning
                if (isDragging) {
                    const pos = getPointerPos(e);
                    const dx = pos.x - lastPos.x;
                    const dy = pos.y - lastPos.y;

                    viewOffset.x += dx;
                    viewOffset.y += dy;
                    lastPos = pos;
                }
            }

            function onUp(e) {
                isDragging = false;
                initialPinchDist = null;
            }

            function onWheel(e) {
                e.preventDefault();
                scale += e.deltaY * -0.001;
                scale = Math.min(Math.max(0.1, scale), 5);
            }

            function openGoogleContact(data) {
                if (!data.rawId) return;
                const url = `https://contacts.google.com/person/${data.rawId}`;
                window.open(url, '_blank');
            }

            // Listeners
            canvas.addEventListener('mousedown', onDown);
            window.addEventListener('mousemove', onMove);
            window.addEventListener('mouseup', onUp);

            canvas.addEventListener('touchstart', onDown, { passive: false });
            window.addEventListener('touchmove', onMove, { passive: false });
            window.addEventListener('touchend', onUp);
            canvas.addEventListener('wheel', onWheel, { passive: false });

            // Buttons
            const btnReset = document.getElementById('reset-cam-button');
            if (btnReset) btnReset.onclick = () => { viewOffset = { x: 0, y: 0 }; scale = 0.8; };

            const btnFind = document.getElementById('find-button');
            if (btnFind) btnFind.onclick = findNode;

            function findNode() {
                const el = document.getElementById('find-input');
                if (!el) return;
                const val = el.value.toLowerCase();
                const node = nodes.find(n => n.data.name.toLowerCase().includes(val));
                if (node) {
                    viewOffset.x = -node.x * scale;
                    viewOffset.y = -node.y * scale;
                    node.highlight = Date.now() + 2000;
                }
            }

            // --- Animation Loop ---
            function resize() { canvas.width = container.clientWidth; canvas.height = container.clientHeight; }
            window.addEventListener('resize', resize);
            resize();

            function update() {
                // Physics: Repulsion
                for (let i = 0; i < nodes.length; i++) {
                    for (let j = i + 1; j < nodes.length; j++) {
                        const a = nodes[i], b = nodes[j];
                        const dx = b.x - a.x, dy = b.y - a.y;
                        const distSq = dx * dx + dy * dy || 1;
                        if (distSq > 100000) continue;
                        const force = 1500 / distSq;
                        const dist = Math.sqrt(distSq);

                        const fx = (dx / dist) * force;
                        const fy = (dy / dist) * force;

                        a.vx -= fx; a.vy -= fy;
                        b.vx += fx; b.vy += fy;
                    }
                }

                // Physics: Springs (Edges)
                edges.forEach(e => {
                    const a = nodes.find(n => n.id === e.source);
                    const b = nodes.find(n => n.id === e.target);
                    if (!a || !b) return;
                    const dx = b.x - a.x, dy = b.y - a.y;
                    const dist = Math.sqrt(dx * dx + dy * dy) || 1;
                    const force = (dist - 200) * 0.05;

                    const fx = (dx / dist) * force;
                    const fy = (dy / dist) * force;

                    a.vx += fx; a.vy += fy;
                    b.vx -= fx; b.vy -= fy;
                });

                // Physics: Apply
                nodes.forEach(n => {
                    n.vx -= n.x * 0.001; // Center gravity
                    n.vy -= n.y * 0.001;

                    n.x += n.vx;
                    n.y += n.vy;
                    n.vx *= 0.90; // Friction
                    n.vy *= 0.90;
                });
            }

            function draw() {
                ctx.save();
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                ctx.translate(canvas.width / 2 + viewOffset.x, canvas.height / 2 + viewOffset.y);
                ctx.scale(scale, scale);

                // Edges
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 1.5;
                ctx.beginPath();
                edges.forEach(e => {
                    const a = nodes.find(n => n.id === e.source);
                    const b = nodes.find(n => n.id === e.target);
                    if (a && b) {
                        ctx.moveTo(a.x, a.y);
                        ctx.lineTo(b.x, b.y);
                    }
                });
                ctx.stroke();

                // Nodes
                nodes.forEach(n => {
                    const isHighlight = n.highlight && n.highlight > Date.now();

                    ctx.save();
                    ctx.translate(n.x, n.y);

                    ctx.beginPath();
                    ctx.arc(0, 0, NODE_RADIUS, 0, Math.PI * 2);
                    ctx.closePath();

                    ctx.save();
                    ctx.clip();

                    if (n.img && n.isLoaded) {
                        ctx.drawImage(n.img, -NODE_RADIUS, -NODE_RADIUS, NODE_RADIUS * 2, NODE_RADIUS * 2);
                    } else {
                        ctx.fillStyle = '#111';
                        ctx.fill();
                        ctx.fillStyle = '#fff';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.font = 'bold 12px Arial';
                        ctx.fillText(n.data.name ? n.data.name.substring(0, 2).toUpperCase() : '?', 0, 0);
                    }
                    ctx.restore();

                    ctx.strokeStyle = isHighlight ? '#fff' : '#666';
                    ctx.lineWidth = isHighlight ? 3 : 1.5;
                    ctx.stroke();

                    if (scale > 0.6 || isHighlight) {
                        ctx.fillStyle = isHighlight ? '#fff' : '#aaa';
                        ctx.textAlign = 'center';
                        ctx.font = '10px Arial';
                        ctx.fillText(n.data.name, 0, NODE_RADIUS + 12);
                    }

                    ctx.restore();
                });

                ctx.restore();
                requestAnimationFrame(draw);
            }

            setInterval(update, 1000 / 60);
            draw();
        }
    </script>
    <script async defer src="https://apis.google.com/js/api.js" onload="gapiLoaded()"></script>
    <script async defer src="https://accounts.google.com/gsi/client" onload="gisLoaded()"></script>

</body>

</html>